This is important, quite IMPORTANT, ==IF== you need to create .po files for language translations

Lazarus 1.6 and lower has a bug where multi-line hints, edits, labels, etc are not properly converted
for .po (language) files. I'm hoping this is all fixed in laz 1.8. The normal choices that I could Find all used locale for the files. I DON'T want this, I want the user to be able to choose anything they want.

So I made changes to 3 files in the lazarus source code. Two of these units I made copies of and saved locally:

lcl/LCLTranslator ===> unitjLCLTranslator
lcl/translations.pas  ====>  unitjtranslations.pas

This ensures language switching is all ok.

(Hopefully all this is fixed in lazarus 1.8, I'm going to try that next when this is done)



Here is the ===> IMPORTANT PART:

if YOU want to create .po files that support the multiline hints (which I use for help text) you
need to change TWO sourcefiles:

First:

ide/sourcefilemanager.pas


In unit SourceFileManager find this procedure and use the code within the ====== section:


procedure TLRTGrubber.Grub(Sender: TObject; const Instance: TPersistent;
  PropInfo: PPropInfo; var Content: string);
var
  LRSWriter: TLRSObjectWriter;
  Path: String;
begin
  if not Assigned(Instance) then exit;
  if not Assigned(PropInfo) then exit;
  if SysUtils.CompareText(PropInfo^.PropType^.Name,'TTRANSLATESTRING')<>0 then exit;
  if Writer.Driver is TLRSObjectWriter then begin
    LRSWriter:=TLRSObjectWriter(Writer.Driver);
    Path:=LRSWriter.GetStackPath;
  end else begin
    Path:=Instance.ClassName+'.'+PropInfo^.Name;
  end;
  
===========================================  
  //FGrubbed.Add(Uppercase(Path)+'='+Content);
//This gives a + indicator that is used by translator to recoginize mulitLine text...
  FGrubbed.Add(Uppercase(Path)+'='+stringreplace( Content, LineEnding, LineEnding + '+', [rfreplaceall,rfignorecase] ));
===========================================  
  
  //DebugLn(['TLRTGrubber.Grub "',FGrubbed[FGrubbed.Count-1],'"']);
end;


Second:
lcl/translations.pas
there are two sections of the proc that need to be changed, look for ===================

procedure TPOFile.UpdateStrings(InputLines: TStrings; SType: TStringsType);
var
  i,j,n: integer;
  p: LongInt;
  Identifier, Value,Line: string;
  Ch: Char;
  MultiLinedValue: boolean;

  =============================================
  function NextLine : boolean;
  begin
    result := true;
    if i<InputLines.Count then
      inc(i)
    else result := false;
    if i<InputLines.Count then
      Line := InputLines[i]
    else
      Line := '';
    n := Length(Line);
    p := 1;
  end;
  =============================================

  procedure UpdateFromRsj;
  var
    Parser: TJSONParser;
    JsonItems: TJSONArray;
    JsonData, JsonItem: TJSONObject;
    I: Integer;
  begin
    Parser := TJSONParser.Create(InputLines.Text);
    try
      JsonData := Parser.Parse as TJSONObject;
      try
        JsonItems := JsonData.Arrays['strings'];
        for I := 0 to JsonItems.Count - 1 do
        begin
          JsonItem := JsonItems.Items[I] as TJSONObject;
          UpdateItem(JsonItem.Get('name'), JsonItem.Get('value'));
        end;
      finally
        JsonData.Free;
      end;
    finally
      Parser.Free;
    end;
  end;

begin
  ClearModuleList;
  UntagAll;
  if SType = stRsj then
    UpdateFromRsj
  else
  begin
    // for each string in lrt/rst list check if it's already in PO
    // if not add it
    Value := '';
    Identifier := '';
    i := 0;
    while i < InputLines.Count do begin

      Line := InputLines[i];
      n := Length(Line);

      if n=0 then
        // empty line
      else
      if SType=stLrt then begin
  =============================================
//reset to top of lines
        dec( i );
        MultiLinedValue := false;
        value := '';
        while NextLine do
        begin

          p:=Pos('=',Line);

          if ( p > 0 ) and ( pos( 'T', Line ) = 1 ) then
          begin
            if value <> '' then
            begin
              if MultiLinedValue then
                Value := Value + LineEnding;
              UpdateItem(Identifier, Value);
              Value := '';
              MultiLinedValue := false;
            end;
            Value :=copy(Line,p+1,n-p); //if p=0, that's OK, all the string
            Identifier:=copy(Line,1,p-1);
          end
          else
          begin
            MultiLinedValue := true;
//This removes the + indicator added in TLRTGrubber.Grub, p is 0 in this branch so we read p+2
            Value := Value + LineEnding + copy(Line,p+2,n-p);
          end;

        end;

        if Value <> '' then
          UpdateItem(Identifier, Value);
  =============================================

      end else begin
        // rst file
        if Line[1]='#' then begin
          // rst file: comment

          Value := '';
          Identifier := '';
          MultilinedValue := false;

        end else begin

          p:=Pos('=',Line);
          if P>0 then begin

            Identifier := copy(Line,1,p-1);
            inc(p); // points to ' after =

            Value := '';
            while p<=n do begin

              if Line[p]='''' then begin
                inc(p);
                j:=p;
                while (p<=n)and(Line[p]<>'''') do
                  inc(p);
                Value := Value + copy(Line, j, P-j);
                inc(p);
                continue;
              end else
              if Line[p] = '#' then begin
                // a #decimal
                repeat
                  inc(p);
                  j:=p;
                  while (p<=n)and(Line[p] in ['0'..'9']) do
                    inc(p);

                  Ch := Chr(StrToInt(copy(Line, j, p-j)));
                  Value := Value + Ch;
                  if Ch in [#13,#10] then
                    MultilinedValue := True;

                  if (p=n) and (Line[p]='+') then
                    NextLine;

                until (p>n) or (Line[p]<>'#');
              end else
              if Line[p]='+' then
                NextLine
              else
                inc(p); // this is an unexpected string
            end;

            if Value<>'' then begin
              if MultiLinedValue then begin
                // check that we end on lineending, multilined
                // resource strings from rst usually do not end
                // in lineending, fix here.
                if not (Value[Length(Value)] in [#13,#10]) then
                  Value := Value + LineEnding;

                //treat #10#13 sequences as #13#10 for consistency,
                //e.g. #10#13#13#13#10#13#10 should become #13#10#13#13#10#13#10
                p:=2;
                while p<=Length(Value) do begin
                  if (Value[p]=#13) and (Value[p-1]=#10) then begin
                    Value[p]:=#10;
                    Value[p-1]:=#13;
                  end;
                  // further analysis shouldn't affect found #13#10 pair
                  if (Value[p]=#10) and (Value[p-1]=#13) then
                    inc(p);
                  inc(p);
                end;
                Value := AdjustLineBreaks(Value);
              end;
              // po requires special characters as #number
              p:=1;
              while p<=length(Value) do begin
                j := UTF8CharacterLength(pchar(@Value[p]));
                if (j=1) and (Value[p] in [#0..#9,#11,#12,#14..#31,#127..#255]) then
                  Value := copy(Value,1,p-1)+'#'+IntToStr(ord(Value[p]))+copy(Value,p+1,length(Value))
                else
                  inc(p,j);
              end;

              UpdateItem(Identifier, Value);
            end;

          end; // if p>0 then begin
        end;
      end;

      inc(i);
    end;
  end;

  RemoveUntaggedModules;
end;



A further tip for .po makers:

.po files are found in folder "po_files" and in "languages".

in po_files is a template file, and explanatory text file.

In order to update all the files when new text is added to forms or when new resourcestrings are made you need to build with i8n on...twice. First have i8n pointing to po_files, then build. Then point i8n to languages, then build again. 

Now all .po files are updated and the po files in languages can be translated for the new lines.

I've not figured out completely why there are "fuzzy" transalations, there are always a handful. If you do not go through and mark them unfuzzy they WILL NOT get translated. ====>> So make sure you do that.
